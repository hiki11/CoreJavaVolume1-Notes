# Java核心技术 卷1 笔记

## 第4章 对象与类

1、面向对象程序设计（OOP），Java是完全面向对象的。

传统的结构化设计：算法+数据结构=程序，数据结构是第一位，算法第二位。

OOP：数据结构是第一位，算法第二位。OOP适合解决规模较大的问题。

1.1、类（class）：构造对象的模板或蓝图。由类构造（construct）对象的过程称为创建类的实例（instance）。

封装（encapsulation）：将数据和行为组合在一个包，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域（instance field），操纵数据的过程称为方法（method）。

实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。是提高重用性和可靠性的关键。

所有的类都源自一个“神通广大的超类”即Object。在扩展一个已有的类时，这个扩展后的新类具有所扩展的类的全部属性和方法。在新类中，只需提供适用于这个新类的新方法和数据域就可以了。通过扩展一个类建立另一个类的过程称为继承（inheritance）。

1.2、对象：

对象的三个主要特性：

- 对象的行为——可以对对象施加哪些操作，或可以对对象施加哪些方法？
- 对象的状态——当施加那些方法时，对象如何响应？
- 对象表示——如何辨别具有相同行为与状态的不同对象？

对象的特性是相互影响的。比如，状态影响它的行为。（一个订单已送货，那就拒绝条用增删订单条目的方法）。

1.3、识别类：首先从设计类开始，然后再往每个类中添加方法。（学习OOP的方式）

识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。

例如，在订单处理系统中，有着一些名词：项目（Item）、订单（Order）、送货地址（Shipping address）、付款（Payment）、账户（Account），     这些名词很可能成为类Item、Order等

接下来，查看动词：物品项目被添加到订单中，订单被发送或取消。订单货款被支付。对于每个动词：“添加”、“发送”、“取消”以及“支付”，都要标识出主要负责完成动作的对象。例如，当一个新的条目添加到订单中，那个订单对象就是被指定的对象，因为它知道如何存储条目以及对条目进行排序。也就是说，add应该是Order类的一个方法。

1.4、类之间的关系：依赖（“uses-a”）、聚合（“has-a”）、继承（“is-a”）

依赖（dependence），是最明显、常见的关系。例如，Order类使用Account类是因为Order对象需要访问Account对象查看信用状态。一个类的方法操纵另一个类的对象，就是一个类依赖与另一个类。应该尽可能减少相互依赖的类，即降低耦合度。

聚合（aggregation），也可以说是关联（关联的UML符号不易区分）。例如，一个Order对象包含一些Item对象。聚合关系意味着类A的对象包含类B的对象。

![img](/Users/michael/Documents/Notes/Java核心技术笔记/image/屏幕快照 2020-11-06 上午11.40.16.png)

继承（inheritance），用于表示特殊与一般关系。例如，RushOrder类由Order类继承而来。在具有特殊性的RushOrder类中包含一些特殊方法，其他一般方法由Order继承而来。

通过UML（Unified Modeling Language，统一建模语言）来描述类之间的关系。

2、使用预定义类：并不是所有类都具有面向对象特征。如Math.random。

2.1、对象与对象变量：想要使用对象，就必须先构造对象，并指定其初始化状态。然后，对对象应用方法。

Java中使用构造器（Constructor）构造新实例。构造器的名字应该与类名相同，是一种特殊的方法，比如Date类的构造器名为Date。要构造一个对象，需要在构造器前面加上new操作符`new Date()`。构造的对象可以存放在一个变量中`Date birthday = new Date();`。

对象与对象变量存在一个重要的区别，例如：`Date deadlin`只是一个对象变量，可以引用Date类型的对象，但它不是一个对象，实际上也没有引用。此时不能讲任何Date方法应用在这个变量上。

一定要认识到：一个对象变量并没有实际包含一个对象，仅仅是引用一个对象。

在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。如：`Date deadline = new Date();`有两个部分。表达式new Date()构造了一个Date类型的对象，并且它的值是对新创建对象的引用。这个引用存储在变量deadline中。

可以显式地将对象变量设置为null，表名这个对象变量目前没有引用任何对象。局部变量不会自动初始化为null，必需调用new或设置为null来初始化。

所有的Java对象都存储在堆中。当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针。使用一个未初始化的指针，运行系统会产生一个运行时错误。

2.2、Java类库中的GregorianCalendar类：标准Java类库分别包含了两个类：一个是用来表示时间点的Date类；另一个用来表示大家熟悉的日历表示法的GregorianCalendar类，GregorianCalendar类扩展了一个更加通用的Calendar类，这个类描述了日历的一般属性。

将时间和日历分开是一中很好的面向对象设计。通常，最好使用不同的类表示不同的概念。Date类只提供了少量的方法用来比较两个时间点，例如before和after方法表示是否早于或晚于一个时间点。

使用new GregorianCalendar()构建新对象，还可以通过提供年月日表示日历对象，怪异的事，月份从0开始计数。

2.3、更改器方法与访问器方法：...

3、用户自定义类：学习设计复杂应用所需要的主力类（workhorse class）。通常这些类没有main方法，却又自己的实例域和实例方法。想要创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有main方法。

3.1、Employee类

在Java中，最简单的类定义形式为：

```java
class ClassName {
  field1
  field2
  ...
  constructor1
  constructor2
  ...
  method1
  method2
  ...
}
```

一个简单的Employee类：

```java
class Employee {
  // instance fields
  private String name;
  private double salary;
  private Date hireDay;
  
  // constructor
  public Employee(String n, double s, int year, int month, int day) {
    name = n;
    salary = s;
    GregorianCalendar calendar = new GregorianCalendar(year, month - 1, day);
  }
      
  // a method
  public String getName() {
    return name;
  }

  // more method
  ...
}
```

3.2、多个源文件的使用：许多程序员习惯于将每一个类存在一个单独的源文件中。编译EmployeeTest.java，其使用了Employee类，那么Java编译器就会自动搜索Employee.java进行编译。并且Employee.java若版本较已有Employee.java版本新，那么Java编译器会自动重新编译这个文件。

3.3、剖析Employee类：方法可以有4中访问级别，实例（name、salary...）是private关键字，确保只有类自身的方法才能访问这些实例域，其他类的方法不能够读写这些域。（并不建议public实例域，这会破坏封装，任何类的任何方法都可以修改public域）

3.4、构造器：构造器与类同名，在构造 类的对象时，构造器会运行，以便将实例域初始化为所希望的状态。构造器与其他的方法有一个重要的不同，构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的，这个将会产生编译错误。

构造器的主要点：①构造器与类同名②每个类可以有一个以上的构造器③构造器可以有0个、1个或多个参数④构造器没有返回值⑤构造器总是伴随着new操作一起调用

警告：不要在构造器中定义与实例域重名的局部变量（这些变量会屏蔽同名的实例域）。

3.5 隐式参数与显式参数：salary称为隐式（implicit）参数，byPercent称为显式（explicit）参数，位于方法名后面括号中的数值，并且有方法声明。

关键字this表示隐式参数，隐式参数没有出现在方法声明中。

```java
public void raiseSalary(double byPercent) {
  double raise = this.salary * byPercent / 100;
  this.salary += raise;
}
```

3.6、封装的优点：Java的特性。访问器方法getXxx，更改器方法setXxx。

在有些时候，需要获得或设置实例域的值。因此，应该提供下面三项内容:

* 一个私有的数据城;
* 一个公有的城访问器方法
* 一个公有的域更改器方法。

好处是①可以改变内部实现，除了该类的方法之外，不会影响其他代码。②更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行着些处理。例如，setSalary方法可以检查薪金是否小于0。

警告：不要编写返回引用可变对象的访问器方法。例如getHireDay方法返回了一个Date类对象：

```java
class Employee {
  private Date hireDay;
  ...
  public Date getHireDay() {
    return hireDay;
  }
  ...
}
```

这会破坏封装性！如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone）。即`return hireDay.clone()`。

3.7、基于类的访问权限：一个方法可以访问所属类的所有对象的私有数据。

3.8、私有方法：绝大多数方法都设计为公有的，但在某些特殊情况下，可也能将它们设计为私有的。

3.9、final实例域：大多应用于基本（primitive）类型域，或不可变（immutable）类的域【如String】。如果是可变的类，比如`private final Date hiredate;`只意味着存储在hiredate变量中的对象引用在对象构造之后不能被改变，而并不意味着hiredate对象是一个常量，任何方法都可以对hiredate引用的对象调用setTime更改器。将实例域定义为final，构建对象时必须初始化这样的域。

4.1、静态域：将域定义为static，则每个类中只有一个这样的域。而每个对象对于所有的实例域都有自己的一份拷贝。

```java
class Employee {
  private static int nextId = 1;
  private int id;
}
```

每个雇员对象都有一个自己的id域，但这个类的所有实例将共享一个nextId域。也就是说，如果有1000个Employee类的对象，则有1000个实例域id，但只有一个静态域nextId。即使没有一个对象，静态域也存在，它属于类而不是与任何独立对象。

4.2、静态常量：如

```java
public class Math {
  public static final double PI = 3.14158...;
}
```

在程序中，可以采用Math.PI的形式获得这个常量。如果static被省略，PI就变成了Math类的一个实例域。需要通过Math类的对象访问PI，并且每个Math对象都有自己的一份PI拷贝。

System.out是常用的静态常量（static final）。由于每个类对象都可以对公有域进行修改，所以最好不要将域设计为public，然而公有常量（即final域）可以。因为out被声明为final。所以不允许再讲其他打印流赋给它。

4.3、静态方法：不能向对象实施操作的方法。比如Math类的pow方法就是一个静态方法。在运算时，不使用任何Math对象。也就是没有隐式的参数。可以认为静态方法是没有this参数的方法。

静态方法不能操作对象，所以不能再静态方法中访问实例域。但可以访问自身类中的静态域。

注释：可以使用对象调用静态函数。比如harry是一个Employee对象，可以用harry.getNextId()代替Employee.getNextId()。但这种防疫容易混淆，因为getNextId方法计算的结果与harry无关，因此建议使用类名。

在下面两种情况使用静态方法：①一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（如Math.pow）。②一个方法只需要访问类的静态域（如：Employee.getNextId）。

4.4、工厂方法：静态方法的一种常见用途。NumberFormat类使用工厂方法产生不同风格的格式对象。

```java
NumberFormat currency = NumberFormat.getCurrencyInstance();
NumberFormat percentFormatter = NumberFormat.getPercentInstance();
double x = 0.1;
System.out.println(currencyFormatter.format(x)); // prints $0.10
System.out.println(percentFormatter.format(x)); // prints 10%
```

为什么NumberFormat不利用构造器完成这些操作呢？原因：①无法命名构造器，狗仔起的名字必需与类名相同。②当使用构造器时，无法改变所构造的对象类型。

4.5、main方法：不需要使用对象调用静态方法，例如main方法。面方法不对任何对象进行操作。在启动程序时还没有任何一个对象，静态的main方法将执行并创建程序所需要的对象。

提示：每个类可以有一个main方法。通常应用于单元测试。

5、方法参数：按值调用（call by value）、按引用调用（call by reference）一个方法可以修改传递引用所对应的变量值，但不能修改传递值调用所对应的变量值。Java程序设计语言总是按值调用，也就是说，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。

但方法参数有两种类型：①基本数据类型（数字、布尔值）②对象引用

由于Java是按值调用，参数为对象引用时是地址的一个拷贝。但不能交换两个对象的地址（值引用的原因）。

* 一个方法不能修改一个进本数据类型的参数
* 一个方法可以改变一个对象参数的状态
* 一个方法不能让对象参数引用一个新的对象

6、对象构造（非常重要）

6.1重载

注释：Java允许重载任何方法，而不只是构造器方法。因此要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名（signature）。例如签名`indexOf(int)`。返回类型不是签名的一部分，也就是说不能有两个名字相同、参数一类型也相同而返回类型不同的方法。

6.2、默认域初始化：如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。然而，只有缺少程序设计经验的人才会这样做。如果不明确地对域进行初始化，就会影响程序代码的可读性。

6.3、无参数的构造器：在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器，这个构造器将所有的实例域设置为默认值。如果提供了构造器，但没有提供无参数的构造器，那么构造对象时没有提供参数就会视为不合法。

6.4、显式域初始化：在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，这种方式特别有用。初始值不一定是常量，也可以调用方法对域进行初始化。

6.5、参数名：编写小的构造器时，少用单个字符命名，可以在要初始化的参数前价格前缀“a”等，如“aSalary”，`salary = aSalary`。或者可以用相同名字的参数，将实例域屏蔽起来，但可以调用this.salary的形式访问实例域，如`this.salary = salary`。

6.6、调用另一个构造器：`this(...)`可以调用同一个类的另一个构造器。这样可以只写一次公共的构造器代码。

6.7、初始化块：在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。首先运行初始化块，然后才运行构造器的主体部分。

```java
class Employee {
  private static int nextId;
  
  private int id;
  private String name;
  private double salary;
  
  // object initialization block
  {
    id = nextId;
    nextId++;
  }
  
  public Employee(String n, double s) {
    name = n;
    salary = s;
  }
  
  public Employee() {
    name = "";
    salary = 0;
  }
  ...
}
```

这种机制不是必须，也不常见。通常是直接将初始化代码放在构造器中。

调用构造器的具体步骤：1)所有数据被初始化为默认值 2)按照在类声明中出现的次序，一次执行所有域初始化语句和初始化块。 3)如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。 4)执行这个构造器的主体。

可以通过提供一个初始化值，或者使用一个静态的初始化块来对静态域进行初始化。如果类的静态域进行初始化的代码比较复杂，可以用静态的初始化块。（static标记块）

类第一次加载时，会进行静态域的初始化。与实例域一样，没有显式设置，那么有默认值。执行顺序按照类定义的顺序执行。

6.8、对象析构与finalize方法：C++有显式的析构器，析构器最常见的操作是回收分配给对象的存储空间。Java有自动地垃圾回收期，所以不支持析构器。

当某些对象使用了内存之外的其他资源，如文件或使用了系统资源的另一个对象的句柄。可以为一个类添加finalize方法，finalize方法将在垃圾回收期清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源，因为很难知道这个方法什么时候才能调用。

注释：System.runFinalizersOnExit(true)的方法可以确保finalizer方法在Java关闭前被调用，但并不安全不鼓励使用。替代方法是Runtime.addShutdownHook。

对象用完时，可以应用一个close方法来完成相应的清理操作。

7、包：借助于包（package）可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。

从编译器的角度来看，嵌套的包之间没有任何关系。例如，java.util包与java.util.jar包毫无关系。每一个都拥有独立的类集合。

7.1、类的导入：一个类可以使用所属包中的所有类，以及其他包中的共有类（public class）。

两种方式访问另一个包中的共有类：①（麻烦）每个类名前添加完整的包名`java.util.Date today = new java.util.Date()`②使用import语句，如：`import java.util.*;`，或者`import java.util.Date;`。前者对代码的大小也没有任何负面影响。

但要注意的是，只能用星号\*导入一个包，而不能所有包都导入，如`import java.*`或`import java.*.*`。

命名冲突：`java.util`和`java.sql`都有Date类，同时导入会产生编译错误，这时需要在类名前加上完整包名，即方法①。

7.2、静态导入：导入静态方法和静态域。如`import static java.lang.Math.*;`，那么可以直接使用`sql()`等函数。

警告：编译器在编译源文件的时候不检查目录结构。如`package com.mycompany`即使源文件没有在子目录下，也可以进行编译。但最终的程序无法运行，因为虚拟机找不到类文件。

7.4、包作用域：public可以被任意的类使用，private只能被定义它们的类使用。如果没有指定普办理或者private，那么可以被同一个包中的所有方法访问。对于类来说，同一个包的其他类可以访问合乎情理，但变量就不合适了，应该显式标记为private，否则会破坏封装性。

从1.2版开始，JDK的实现者修改了类加载器，明确地禁止加载用户自定义的、包名以“java.”开始的类。

8、类路径：是所有包含类文件的路径的集合。类的路径必需与包名匹配。

JAR文件使用ZIP格式组织文件和子目录。可以使用所有ZIP实用程序查看内部的rt.jar以及其他的JAR文件。

为了使类能够被多个程序共享：①把类放到一个目录中，注意目录是包树状结构的基目录②将JAR文件放在一个目录中③设置类路径（class path）

警告：javac编译器总是在当前的目录中查找文件，但Java虚拟机仅在类路径中有“.”目录的时候材查看当前目录。如果没有设置类路径，也不会有问题，默认类路径包含“.”目录。然而如果设置了类路径却忘记了包含“.”目录，则程序仍然可以通过编译，但不能运行。

虚拟机要搜寻com.horstmann.corejava.Employee类文件。它首先要查看存储在jre/lib和jre/lib/ext目录下的归档文件中所存放的系统类文件。找不到，然后再查看类路径。

编译器定位文件比虚拟机复杂很多。如果引用了一个类，而没有指出这个类所在的包，那么编译器辉县查找包含这个类的包，并查询所有的import指令，确定其中是否有这个类。

编译器可以查看源文件（Source files）是否比类文件新，如果是，那么源文件就会被自动重新编译。

设置类路径：不应该将CLASSPATH环境变量设置为永久不变的值。不应该绕开类路径，将所有的文件放在jre/lib/ext路径。

9、文档注释：

注释以`/**`开始，`*/`结束。每个/**...*/文档注释在标记之后紧跟着自由格式文本（free-form text）。标记由@开始，如@author或@param。

9.2、类注释：必需放在import语句之后，类定义之前。没有必要在每一行的开始用星号*，但大部分IDE都提供了这种功能。

9.3、方法注释：@param 变量描述，@return 描述，@throws 类描述

9.5、通用注释：@author 姓名，@version 文本，@since 文本，@deprecated 文本，@see 引用（可以指定超链接）

9.6、包与概述注释

10、类设计技巧：更具OOP水准。①保证数据私有（即封装性，如实例域的私有）②数据初始化③不要在类中食用过多的基本类型，例如可以用一个称为Address的新类替换以下实例域。

```java
private String street;
private String city;
private String state;
private int zip;
```

④不是所有的域都需要独立的域访问器和域更改器⑤将职责过多的类进行分解⑥类名和方法名要能够体现它们的职责
