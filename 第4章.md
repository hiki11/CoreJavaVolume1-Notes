# Java核心技术 卷1 笔记

## 第4章 对象与类

1、面向对象程序设计（OOP），Java是完全面向对象的。

传统的结构化设计：算法+数据结构=程序，数据结构是第一位，算法第二位。

OOP：数据结构是第一位，算法第二位。OOP适合解决规模较大的问题。

1.1、类（class）：构造对象的模板或蓝图。由类构造（construct）对象的过程称为创建类的实例（instance）。

封装（encapsulation）：将数据和行为组合在一个包，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域（instance field），操纵数据的过程称为方法（method）。

实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。是提高重用性和可靠性的关键。

所有的类都源自一个“神通广大的超类”即Object。在扩展一个已有的类时，这个扩展后的新类具有所扩展的类的全部属性和方法。在新类中，只需提供适用于这个新类的新方法和数据域就可以了。通过扩展一个类建立另一个类的过程称为继承（inheritance）。

1.2、对象：

对象的三个主要特性：

- 对象的行为——可以对对象施加哪些操作，或可以对对象施加哪些方法？
- 对象的状态——当施加那些方法时，对象如何响应？
- 对象表示——如何辨别具有相同行为与状态的不同对象？

对象的特性是相互影响的。比如，状态影响它的行为。（一个订单已送货，那就拒绝条用增删订单条目的方法）。

1.3、识别类：首先从设计类开始，然后再往每个类中添加方法。（学习OOP的方式）

识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。

例如，在订单处理系统中，有着一些名词：项目（Item）、订单（Order）、送货地址（Shipping address）、付款（Payment）、账户（Account），     这些名词很可能成为类Item、Order等

接下来，查看动词：物品项目被添加到订单中，订单被发送或取消。订单货款被支付。对于每个动词：“添加”、“发送”、“取消”以及“支付”，都要标识出主要负责完成动作的对象。例如，当一个新的条目添加到订单中，那个订单对象就是被指定的对象，因为它知道如何存储条目以及对条目进行排序。也就是说，add应该是Order类的一个方法。

1.4、类之间的关系：依赖（“uses-a”）、聚合（“has-a”）、继承（“is-a”）

依赖（dependence），是最明显、常见的关系。例如，Order类使用Account类是因为Order对象需要访问Account对象查看信用状态。一个类的方法操纵另一个类的对象，就是一个类依赖与另一个类。应该尽可能减少相互依赖的类，即降低耦合度。

聚合（aggregation），也可以说是关联（关联的UML符号不易区分）。例如，一个Order对象包含一些Item对象。聚合关系意味着类A的对象包含类B的对象。

![img](/Users/michael/Documents/Notes/Java核心技术笔记/image/屏幕快照 2020-11-06 上午11.40.16.png)

继承（inheritance），用于表示特殊与一般关系。例如，RushOrder类由Order类继承而来。在具有特殊性的RushOrder类中包含一些特殊方法，其他一般方法由Order继承而来。

通过UML（Unified Modeling Language，统一建模语言）来描述类之间的关系。

2、使用预定义类：并不是所有类都具有面向对象特征。如Math.random。

2.1、对象与对象变量：想要使用对象，就必须先构造对象，并指定其初始化状态。然后，对对象应用方法。

Java中使用构造器（Constructor）构造新实例。构造器的名字应该与类名相同，是一种特殊的方法，比如Date类的构造器名为Date。要构造一个对象，需要在构造器前面加上new操作符`new Date()`。构造的对象可以存放在一个变量中`Date birthday = new Date();`。

对象与对象变量存在一个重要的区别，例如：`Date deadlin`只是一个对象变量，可以引用Date类型的对象，但它不是一个对象，实际上也没有引用。此时不能讲任何Date方法应用在这个变量上。

一定要认识到：一个对象变量并没有实际包含一个对象，仅仅是引用一个对象。

在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。如：`Date deadline = new Date();`有两个部分。表达式new Date()构造了一个Date类型的对象，并且它的值是对新创建对象的引用。这个引用存储在变量deadline中。

可以显式地将对象变量设置为null，表名这个对象变量目前没有引用任何对象。局部变量不会自动初始化为null，必需调用new或设置为null来初始化。

所有的Java对象都存储在堆中。当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针。使用一个未初始化的指针，运行系统会产生一个运行时错误。

2.2、Java类库中的GregorianCalendar类：标准Java类库分别包含了两个类：一个是用来表示时间点的Date类；另一个用来表示大家熟悉的日历表示法的GregorianCalendar类，GregorianCalendar类扩展了一个更加通用的Calendar类，这个类描述了日历的一般属性。

将时间和日历分开是一中很好的面向对象设计。通常，最好使用不同的类表示不同的概念。Date类只提供了少量的方法用来比较两个时间点，例如before和after方法表示是否早于或晚于一个时间点。

使用new GregorianCalendar()构建新对象，还可以通过提供年月日表示日历对象，怪异的事，月份从0开始计数。

2.3、更改器方法与访问器方法：...

3、用户自定义类：学习设计复杂应用所需要的主力类（workhorse class）。通常这些类没有main方法，却又自己的实例域和实例方法。想要创建一个完整的程序，应该将若干类组合在一起，其中只有一个类有main方法。

3.1、Employee类

在Java中，最简单的类定义形式为：

```java
class ClassName {
  field1
  field2
  ...
  constructor1
  constructor2
  ...
  method1
  method2
  ...
}
```

一个简单的Employee类：

```java
class Employee {
  // instance fields
  private String name;
  private double salary;
  private Date hireDay;
  
  // constructor
  public Employee(String n, double s, int year, int month, int day) {
    name = n;
    salary = s;
    GregorianCalendar calendar = new GregorianCalendar(year, month - 1, day);
  }
      
  // a method
  public String getName() {
    return name;
  }

  // more method
  ...
}
```

3.2、多个源文件的使用：许多程序员习惯于将每一个类存在一个单独的源文件中。编译EmployeeTest.java，其使用了Employee类，那么Java编译器就会自动搜索Employee.java进行编译。并且Employee.java若版本较已有Employee.java版本新，那么Java编译器会自动重新编译这个文件。

3.3、剖析Employee类：方法可以有4中访问级别，实例（name、salary...）是private关键字，确保只有类自身的方法才能访问这些实例域，其他类的方法不能够读写这些域。（并不建议public实例域，这会破坏封装，任何类的任何方法都可以修改public域）

3.4、构造器：构造器与类同名，在构造 类的对象时，构造器会运行，以便将实例域初始化为所希望的状态。构造器与其他的方法有一个重要的不同，构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的，这个将会产生编译错误。

构造器的主要点：①构造器与类同名②每个类可以有一个以上的构造器③构造器可以有0个、1个或多个参数④构造器没有返回值⑤构造器总是伴随着new操作一起调用

警告：不要在构造器中定义与实例域重名的局部变量（这些变量会屏蔽同名的实例域）。

3.5 隐式参数与显式参数：salary称为隐式（implicit）参数，byPercent称为显式（explicit）参数，位于方法名后面括号中的数值，并且有方法声明。

关键字this表示隐式参数，隐式参数没有出现在方法声明中。

```java
public void raiseSalary(double byPercent) {
  double raise = this.salary * byPercent / 100;
  this.salary += raise;
}
```

3.6、封装的优点：Java的特性。访问器方法getXxx，更改器方法setXxx。

在有些时候，需要获得或设置实例域的值。因此，应该提供下面三项内容:

* 一个私有的数据城;
* 一个公有的城访问器方法
* 一个公有的域更改器方法。

好处是①可以改变内部实现，除了该类的方法之外，不会影响其他代码。②更改器方法可以执行错误检查，然而直接对域进行赋值将不会进行着些处理。例如，setSalary方法可以检查薪金是否小于0。

警告：不要编写返回引用可变对象的访问器方法。例如getHireDay方法返回了一个Date类对象：

```java
class Employee {
  private Date hireDay;
  ...
  public Date getHireDay() {
    return hireDay;
  }
  ...
}
```

这会破坏封装性！如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone）。即`return hireDay.clone()`。

3.7、基于类的访问权限：一个方法可以访问所属类的所有对象的私有数据。

3.8、私有方法：绝大多数方法都设计为公有的，但在某些特殊情况下，可也能将它们设计为私有的。

3.9、final实例域：大多应用于基本（primitive）类型域，或不可变（immutable）类的域【如String】。如果是可变的类，比如`private final Date hiredate;`只意味着存储在hiredate变量中的对象引用在对象构造之后不能被改变，而并不意味着hiredate对象是一个常量，任何方法都可以对hiredate引用的对象调用setTime更改器。将实例域定义为final，构建对象时必须初始化这样的域。

4.1、静态域：将域定义为static，则每个类中只有一个这样的域。而每个对象对于所有的实例域都有自己的一份拷贝。

```java
class Employee {
  private static int nextId = 1;
  private int id;
}
```

每个雇员对象都有一个自己的id域，但这个类的所有实例将共享一个nextId域。也就是说，如果有1000个Employee类的对象，则有1000个实例域id，但只有一个静态域nextId。即使没有一个对象，静态域也存在，它属于类而不是与任何独立对象。

4.2、静态常量：如

```java
public class Math {
  public static final double PI = 3.14158...;
}
```

在程序中，可以采用Math.PI的形式获得这个常量。如果static被省略，PI就变成了Math类的一个实例域。需要通过Math类的对象访问PI，并且每个Math对象都有自己的一份PI拷贝。

System.out是常用的静态常量（static final）。由于每个类对象都可以对公有域进行修改，所以最好不要将域设计为public，然而公有常量（即final域）可以。因为out被声明为final。所以不允许再讲其他打印流赋给它。

4.3、静态方法：不能向对象实施操作的方法。比如Math类的pow方法就是一个静态方法。在运算时，不使用任何Math对象。也就是没有隐式的参数。可以认为静态方法是没有this参数的方法。

静态方法不能操作对象，所以不能再静态方法中访问实例域。但可以访问自身类中的静态域。

注释：可以使用对象调用静态函数。比如harry是一个Employee对象，可以用harry.getNextId()代替Employee.getNextId()。但这种防疫容易混淆，因为getNextId方法计算的结果与harry无关，因此建议使用类名。

在下面两种情况使用静态方法：①一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（如Math.pow）。②一个方法只需要访问类的静态域（如：Employee.getNextId）。

4.4、工厂方法：静态方法的一种常见用途。NumberFormat类使用工厂方法产生不同风格的格式对象。

```java
NumberFormat currency = NumberFormat.getCurrencyInstance();
NumberFormat percentFormatter = NumberFormat.getPercentInstance();
double x = 0.1;
System.out.println(currencyFormatter.format(x)); // prints $0.10
System.out.println(percentFormatter.format(x)); // prints 10%
```

为什么NumberFormat不利用构造器完成这些操作呢？原因：①无法命名构造器，狗仔起的名字必需与类名相同。②当使用构造器时，无法改变所构造的对象类型。

4.5、main方法：不需要使用对象调用静态方法，例如main方法。面方法不对任何对象进行操作。在启动程序时还没有任何一个对象，静态的main方法将执行并创建程序所需要的对象。

提示：每个类可以有一个main方法。通常应用于单元测试。

5、方法参数：按值调用（call by value）、按引用调用（call by reference）一个方法可以修改传递引用所对应的变量值，但不能修改传递值调用所对应的变量值。Java程序设计语言总是按值调用，也就是说，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。

但方法参数有两种类型：①基本数据类型（数字、布尔值）②对象引用

由于Java是按值调用，参数为对象引用时是地址的一个拷贝。但不能交换两个对象的地址（值引用的原因）。

* 一个方法不能修改一个进本数据类型的参数
* 一个方法可以改变一个对象参数的状态
* 一个方法不能让对象参数引用一个新的对象

6、对象构造（非常重要）

6.1重载

注释：Java允许重载任何方法，而不只是构造器方法。因此要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名（signature）。例如签名`indexOf(int)`。返回类型不是签名的一部分，也就是说不能有两个名字相同、参数一类型也相同而返回类型不同的方法。

6.2、默认域初始化：如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。然而，只有缺少程序设计经验的人才会这样做。如果不明确地对域进行初始化，就会影响程序代码的可读性。

6.3、无参数的构造器：在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器，这个构造器将所有的实例域设置为默认值。如果提供了构造器，但没有提供无参数的构造器，那么构造对象时没有提供参数就会视为不合法。

6.4、显式域初始化：在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定的实例域时，这种方式特别有用。初始值不一定是常量，也可以调用方法对域进行初始化。

6.5、参数名：编写小的构造器时，少用单个字符命名，可以在要初始化的参数前价格前缀“a”等，如“aSalary”，`salary = aSalary`。或者可以用相同名字的参数，将实例域屏蔽起来，但可以调用this.salary的形式访问实例域，如`this.salary = salary`。

6.6、调用另一个构造器：`this(...)`可以调用同一个类的另一个构造器。这样可以只写一次公共的构造器代码。

6.7、初始化块：在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。首先运行初始化块，然后才运行构造器的主体部分。

```java
class Employee {
  private static int nextId;
  
  private int id;
  private String name;
  private double salary;
  
  // object initialization block
  {
    id = nextId;
    nextId++;
  }
  
  public Employee(String n, double s) {
    name = n;
    salary = s;
  }
  
  public Employee() {
    name = "";
    salary = 0;
  }
  ...
}
```

这种机制不是必须，也不常见。通常是直接将初始化代码放在构造器中。

调用构造器的具体步骤：1)所有数据被初始化为默认值 2)按照在类声明中出现的次序，一次执行所有域初始化语句和初始化块。 3)如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。 4)执行这个构造器的主体。

可以通过提供一个初始化值，或者使用一个静态的初始化块来对静态域进行初始化。如果类的静态域进行初始化的代码比较复杂，可以用静态的初始化块。（static标记块）

类第一次加载时，会进行静态域的初始化。与实例域一样，没有显式设置，那么有默认值。执行顺序按照类定义的顺序执行。

6.8、对象析构与finalize方法：C++有显式的析构器，析构器最常见的操作是回收分配给对象的存储空间。Java有自动地垃圾回收期，所以不支持析构器。

当某些对象使用了内存之外的其他资源，如文件或使用了系统资源的另一个对象的句柄。可以为一个类添加finalize方法，finalize方法将在垃圾回收期清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源，因为很难知道这个方法什么时候才能调用。

注释：System.runFinalizersOnExit(true)的方法可以确保finalizer方法在Java关闭前被调用，但并不安全不鼓励使用。替代方法是Runtime.addShutdownHook。

对象用完时，可以应用一个close方法来完成相应的清理操作。

7、包：借助于包（package）可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。

从编译器的角度来看，嵌套的包之间没有任何关系。例如，java.util包与java.util.jar包毫无关系。每一个都拥有独立的类集合。

7.1、类的导入：一个类可以使用所属包中的所有类，以及其他包中的共有类（public class）。

两种方式访问另一个包中的共有类：①（麻烦）每个类名前添加完整的包名`java.util.Date today = new java.util.Date()`②使用import语句，如：`import java.util.*;`，或者`import java.util.Date;`。前者对代码的大小也没有任何负面影响。

但要注意的是，只能用星号\*导入一个包，而不能所有包都导入，如`import java.*`或`import java.*.*`。

命名冲突：`java.util`和`java.sql`都有Date类，同时导入会产生编译错误，这时需要在类名前加上完整包名，即方法①。

7.2、静态导入：导入静态方法和静态域。如`import static java.lang.Math.*;`，那么可以直接使用`sql()`等函数。

警告：编译器在编译源文件的时候不检查目录结构。如`package com.mycompany`即使源文件没有在子目录下，也可以进行编译。但最终的程序无法运行，因为虚拟机找不到类文件。

7.4、包作用域：public可以被任意的类使用，private只能被定义它们的类使用。如果没有指定普办理或者private，那么可以被同一个包中的所有方法访问。对于类来说，同一个包的其他类可以访问合乎情理，但变量就不合适了，应该显式标记为private，否则会破坏封装性。

从1.2版开始，JDK的实现者修改了类加载器，明确地禁止加载用户自定义的、包名以“java.”开始的类。

8、类路径：是所有包含类文件的路径的集合。类的路径必需与包名匹配。

JAR文件使用ZIP格式组织文件和子目录。可以使用所有ZIP实用程序查看内部的rt.jar以及其他的JAR文件。

为了使类能够被多个程序共享：①把类放到一个目录中，注意目录是包树状结构的基目录②将JAR文件放在一个目录中③设置类路径（class path）

警告：javac编译器总是在当前的目录中查找文件，但Java虚拟机仅在类路径中有“.”目录的时候材查看当前目录。如果没有设置类路径，也不会有问题，默认类路径包含“.”目录。然而如果设置了类路径却忘记了包含“.”目录，则程序仍然可以通过编译，但不能运行。

虚拟机要搜寻com.horstmann.corejava.Employee类文件。它首先要查看存储在jre/lib和jre/lib/ext目录下的归档文件中所存放的系统类文件。找不到，然后再查看类路径。

编译器定位文件比虚拟机复杂很多。如果引用了一个类，而没有指出这个类所在的包，那么编译器辉县查找包含这个类的包，并查询所有的import指令，确定其中是否有这个类。

编译器可以查看源文件（Source files）是否比类文件新，如果是，那么源文件就会被自动重新编译。

设置类路径：不应该将CLASSPATH环境变量设置为永久不变的值。不应该绕开类路径，将所有的文件放在jre/lib/ext路径。

9、文档注释：

注释以`/**`开始，`*/`结束。每个/**...*/文档注释在标记之后紧跟着自由格式文本（free-form text）。标记由@开始，如@author或@param。

9.2、类注释：必需放在import语句之后，类定义之前。没有必要在每一行的开始用星号*，但大部分IDE都提供了这种功能。

9.3、方法注释：@param 变量描述，@return 描述，@throws 类描述

9.5、通用注释：@author 姓名，@version 文本，@since 文本，@deprecated 文本，@see 引用（可以指定超链接）

9.6、包与概述注释

10、类设计技巧：更具OOP水准。①保证数据私有（即封装性，如实例域的私有）②数据初始化③不要在类中食用过多的基本类型，例如可以用一个称为Address的新类替换以下实例域。

```java
private String street;
private String city;
private String state;
private int zip;
```

④不是所有的域都需要独立的域访问器和域更改器⑤将职责过多的类进行分解⑥类名和方法名要能够体现它们的职责

## 第5章 继承

继承即复用类的方法和域，在此基础上还可以添加一些新的方法和域，满足新的需求。另外还会讲述反射（reflection）的概念。反射是指在程序运行期间发现更多的类及其属性的能力。

5.1、 类、超类和子类

例如新类Manager继承类Employee，并添加一些新功能。那么Manager与Employee存在“is-a”（是）关系，即每个经理都是雇员。`class Manager extends Employee{}`

关键字extends表示继承。父类（parent class）也称为超类（superclass）或基类（base class）；子类（subclass）也称为派生类（derived class）或孩子类（child class）。

Manager类中没有显示定义getName和getHireDay等方法，但仍可以使用，因为它自动集成了超类Employee的这些方法。同样也继承了域。

在设计类的时候，应该将通用的方法放在超类，二将具有特殊用途的方法放在子类。

然而超类的一些方法对子类不一定适用，为此要提供一个新的方法来覆盖（override）。

```java
public double getSalary() {
  return salary + bonus;// won't work
}
```

然而这个方法不能运行，因为Manager的getSalary方法不能直接访问超类的私有域。如果Manager类的方法一定要访问salary域，那么必需借助于公有的接口，也就是Employee类的公有方法getSalary。注意使用关键字super，否则getSalary是无限次地调用本身。

```java
public double getSalary() {
  double baseSalary = super.getSalary();
  return baseSalary + bonus;
}
```

由于子类的构造器不能访问超类构造器，那么可以`super(n, s,...)`调用超类构造其，初始化这部分私有域。

注释：this关键字两个用途：①引用隐式参数②调用该类其他构造器；super两个用途：①调用超类方法②调用超类构造器。调用构造器的语句只能作为另一个构造器的第一条语句出现。

```java
Manager boss = new Manager("Carl Cracker", 80000, 1987, 12, 15);
boss.setBonus(5000);

Employee[] staff = new Employee[3];

staff[0] = boss;
staff[1] = new Employee("Harry Hacker", 50000, 1989, 10 ,1);
staff[2] = new Employee("Tony Tester", 40000, 1990, 3 ,15);

for (Employee e : staff) {
  System.out.println(e.getName() + " " + e.getSalary());
}
```

```
结果是staff[0]，即boss调用了Manager的getSalary()。staff[1]调用了Employee的getSalary()。
```

一个对象变量可以只是多种实际类型的现象被称为多台（polymorphism）。在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。

注释：在Java中，不需要将方法声明为虚拟方法，动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特征，可以标记为final。

1.1、继承层次：即由一个公共超类派生出来的所有类的合集。在继承层次（inheritance hierarchy）中，从某个特定的类到期祖先的路径被称为继承链（inheritance chain）。通常一个祖先类可以拥有多个子孙继承链。

注释：Java不支持多继承。

1.2、多态：判断是否应该设计为继承关系的方法：“is-a”规则，表示子类的每个对象也是超类的对象。例如，每个经理都是雇员，因此Manager类设计为Employee类的子类。

“is-a”的另一种表述法师置换法则，表示程序中出现超类对象的任何地方都可以用子类对象置换。比如可以将一个子类的对象赋给超类变量。

```java
Employee e;
e = new Employee(...);
e = new Manager(...);// 也可以使用
```

Java中，对象变量是多态的。一个变量既可以引用本身的类对象，也可以引用本身类的任何一个子类的对象，但不能反过来超类赋给子类（“is-a”规则）。

警告：Java中，子类数组的引用可以转换成超类对象的引用，而不需要强转。但在这个情况下会发生错误

```java
Manager[] manager = new Manager[10];
Employee[] staff = manager; // 没有问题，不需要强转

staff[0] = new Employee("Harry Hacker",...); // 这样会出现错误，但编译器居然接受了这个赋值操作
```

为了确保不发生这类错误，所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。

1.3、动态绑定

调用对象方法的执行过程：1）编译器查看对象的声明类型和方法名。

2）编译器查看调用方法时提供的参数类型。重载解析（overloading resolution）。

注释：方法的名字和参数列表称为方法的签名，但返回类型不是。因此覆盖方法时，要保证返回类型的兼容性，允许子类将覆盖方法的返回类型定义为原返回类型的子类型。

3）如果是private方法、static方法、final方法，或者构造器，那么编译器可以准确地知道应该调用哪个方法，我们将这种调用方式称之为静态绑定（static binding）。

4）当程序运行，并采用动态绑定调用方法时，虚拟机一定调用与所引用对象的实际类型最合适的那个类的方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它，否则在D类的超类寻找方法，以此类推。

为节省调用方法进行搜索时的时间开销，虚拟机预先为每个类创建一个方法表（method table），列出了所有方法的签名和实际调用的方法。

动态绑定的一个重要的特性：无需对现有的代码进行修改，就可以对程序进行扩展。

警告：在覆盖方法时，子类方法不能低于超类方法的可见性。再声明子类方法的时候，遗漏public修饰符，编译器将会把它解释为识图降低访问权限。

1.4、阻止继承：final类和方法

final类不能被扩展，类中的特定方法也可以被声明为final，那么子类就不能覆盖这个方法（final类的所有方法自动成为final方法）。

注释：域可以可以声明为final。那么final域在构造对象后就不允许改变它们的值了。不过，如果将一个类、声明为final，只有其中的方法会成为final，而不包括域。

内联：如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程就叫内联（inlining）

1.5、强制类型转换：良好习惯→在进行类型转换之前，先查看一下是否能欧成功的转换，可以使用instanceof运算符实现。`staff[1] instanceof Manager`

* 只能在继承层次内进行层次转换
* 在将超类转换为子类之前，应该用instanceof进行检查

注释：如果x为null，那么`x instanceof C`不会产生异常，而是返回false，因为null没有引用任何对象。

实际上，通过类型转换调整对象的类型并不是一种好的做法。一般情况下，尽量少用类型转换和instanceof运算符。在类型转换有问题时，如果没有捕获ClassCastException异常，程序就会终止运行。

1.6、抽象类：abstract关键字。包含抽象方法的类本身必须被声明为抽象的。但抽象类可以包含具体数据和具体方法。

提示：许多程序员认为，在抽象类中不能包含具体方法。建议尽量将通用的域和方法（不管是否为抽象的）放在超类（不管是否为抽象的）中。

抽象方法充当着占位的角色，它们的具体实现在子类中。扩展抽象类可以有两种选择。①在子类中定义部分抽象方法或抽象方法也不定义，那么子类也必须是抽象类②定义全部的抽象方法，子类就不是抽象的了。

类即使不含抽象方法，也可以将类声明为抽象类。

抽象类不能被实例化，也就是说不能创建这个类的对象。但可以创建一个具体子类的对象。需要注意的是，可以定义一个抽象类的对象变量，但它只能引用非抽象子类的对象例如：`Person p = new Student("Vince Vu","Economics");`这里的p是一个抽象类Person的变量，Person引用了一个非抽象子类Student的实例。

1.7、受保护访问：将域标记为private，子类也不能访问超类的域。然而有些时候希望超类的某些方法或域允许被子类访问，可以声明为protected。

实际应用中，要谨慎使用protected属性。一个域中设置了一些受保护域，可能违背OOP提倡的数据封装原则。【详见本书168页】

Object的clone方法就是一个很好的protected示例。

Java的4个访问符归纳：1）仅对本类可见——private。2）对所有类可见——public。3）对本包和所有子类可见——protected。4）对本包可见——默认，不需要修饰符。

2、Object：所有类的超类。那么可以使用Object类型的变量引用任何类型的对象。

在Java中，只有基本类型（primitive types）不是对象。所有的数组类型，不管是对象数组还是基本类型的数组都扩展与Object类。

2.1、equals方法：Object类的equals方法用于检测一个对象是否等于另外一个对象。

在Object类中，这个方法将判断两个对象是否具有相同的引用。

在子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果超类的域都相等，就需要比较子类中的实例域。

2.2、相等测试域继承：如果隐式和显式的参数不属于同一个类，equals方法将如何处理呢？

Java语言规范要求equals方法具有以下特性：1）自反性：对于任何费控引用x，x.equals(x)应该返回true。2）对称性：对于任何引用x和y，当前仅当y.equals(x)返回true，x.equals(y)也应该返回true。3）传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true。4）一致性：如果x和y引用的对象没有变化，反复调用x.equals(y)应该返回同样的结果。5）对于任意非空引用x，x.equals(null)应该返回false。

- 如果子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测
- 如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样可以在不同子类的对象之间进行相等的比较。

编写一个完美的equals方法：1）显式参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量。2）检测this与otherObject是否引用同一个对象：`if (this == otherObject) return true;`。3）检测otherObject是否为null，如果是null，返回false。`if (otherObject == null) return false；`4）比较this与otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变，就使用getClass检测：`if (getClass() != otherObject.getClass()) return false;`5）将otherObject转换为相应的类类型变量：`ClassName other = (ClassName) otherObject`6)对所有需要比较的域进行比较。使用==比较基本类型域，用equals比较对象域。如果所有的域都匹配，返回true，否则false。

提示：对于数组类型的域，可以用静态的Arrays.equals方法比较元素。

警告：覆盖Object类的equals方法时要注意，显示参数类型是Object。为了避免发生类型错误，可以使用Override对覆盖超类的方法进行标记。如果出错了，编译器就会给出错误报告。

2.3、hashCode方法：散列码（hash code）是由对象导出的一个整型值。散列码是没有规律的。如果x和y是不同的两个对象，那么x.hashCode()与y.hashCode()基本不会相同。

```java
// s和t的hashCode是一样的，这是因为字符串的散列码是由内容导出的
String s = "Ok";
String t = new String("Ok");
// sb和tb的hashCode不同，这是因为StringBuilder类中没有定义hashCode方法，它的散列码是由Object类的默认hashCode方法导出的对象存储地址
StringBuilder sb = new StringBuilder(s);
StringBuilder tb = new StringBuilder(t);
```

如果重新定义equals方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散列表中。hashCode可以是负数，对象如果是null则返回0。

Object.hash()方法可以提供多个参数来组合多个散列值。

Equals与hashCode的定义必须一致：也就是说如果x.equals(y)返回true，那么x.hashCode()也必须和y.hashCode()一致。

提示：如果是数组类型的域，那么可以用静态的Arrays.hashCode方法，该散列码由元素的散列码组成。

2.4、toString方法：用于表示对象值的字符串。

只要对象与一个字符串通过操作符“+”连接起来，那么Java编译就会自动地调用toString方法。

提示：基本类型x可以用“”+x来代替toString。

警告：数组继承了Object类的toString方法，因此按照旧的格式打印。正确方式是调用静态方法Arrays.toString。要打印多维数组则是Arrays.deepToString。

toString是非常有用的调试工具。

提示：强烈建议为自定义的每一个类增加toString方法，能从日志记录支持中利人利己。

API：Class getSuperclass()，可以返回一个超类。

3、泛型数组列表：ArrayList。

注释：Java SE 5.0 以前的版本没有提供泛型类，而是有一个ArrayList类，其中保存类型为Object的元素，它是“姿势益康大小的集合”。

注释：在Java程序设计语言的老版本，程序员使用Vector类实现动态数组。

ArrayList用add方法添加元素。如果调用add且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。

如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用ensureCapacity方法。

`staff.ensureCapacity(100);`这个方法将分配一个包含100个对象的内部数组。然后调用100次add，而不用重新分配空间。另外，也可以把初始容量传递给ArrayList构造器：

`ArrayList<Employee> staff = new ArrayList<>(100);`

警告：分配数组列表，如下所示：`new ArrayList<>(100) // capacity is 100`

它与新数组分配空间有所不同：`new Employee[100] // size is 100`

数组列表的容量与数组的大小有一个风场重要的区别。如果为数组分配100个元素的存储空间，数组就有199个空位置可以使用。而容量为100个元素的数组列表只是拥有保存100个元素的潜力（实际上，重新分配空间的话，将会超过100），但是在最初，甚至完成初始化构造之后，数组列表根本就不会含有任何元素。

size方法将返回数组列表中包含的实际元素数目，相当于数组的length。`staff.size()`

一旦确认数组列表的大小不再发生变化，就可以调用trimToSize方法。这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收期将回收多余的存储空间。

一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块，所以应该在确认不会添加任何元素时，再调用trimToSize。

3.1、访问数组列表元素：使用get和set方法实现访问或改变数组元素。

数组列表自动扩展容量的遍历增加了访问元素语法的复杂程度。这是因为ArrayList类并不是Java程序设计语言的一部分，而是由某些人编写并放在标准库中的一个实用类。

警告：只有i小于或等于数组列表的大小（size）时，才能调用set(i, x)。

比如，以下代码是错误的：

```java
ArrayList<Employee> list = new ArrayList<>(100); // 容量（capacity）100，大小（size）为0
list.set(0, x); // 没有元素0
```

注释：没有泛型类时，原始的ArrayList类提供的get方法只能返回Object。原始的ArrayList存在一定危险性，它的add和set方法允许接收任意类型的对象。

既可以扩展数组，又可以方便地访问数组元素：数组列表转数组。

```java
X[] a = new X[list.size()];
list.toArray(a);
```

数组列表的增删元素效率低，适用于小型数组。对于大型数组，又经常要在中间位置增删，应该考虑用链表。

可以使用“for each”循环遍历数组列表。

ArrayList的API：

* void set(int index, T obj)
* T get(int index)
* void add(int index, T obj)
* T remove(int index)

3.2、类型化与原始数组列表的兼容性：可以直接将类型化的数组传递给带原始数组列表的方法，如：

```java
public class Employee08{
  public void update(ArrayList list) {...}
  public ArrayList find(String query) {...}
}

ArrayList<Employee> staff = ...;;
employee08.update(staff);
```

警告：尽管编译器不会给出任何错误信息或警告，但这并不太安全。添加到数组列表中的元素可能不是Employee类型，在检索元素的时候就会出现异常。

但把原始ArrayList赋给一个类型化ArrayList就会得到一个警告。

如果能确保不会造成严重的后果，可以用@SuppressWarnings("unchecked")标注来标记这个变量能够接受类型转换。

4、对象包装器与自动装箱：包装器（wrapper），也叫封装类。

警告：因为每个值都封装在对象中，所以ArrayList<Integer>效率低于int[]，所以适合于小型数组。

Java SE 5.0的一个改进之处是更加便于添加或获得数组元素。如：

```java
list.add(3);
// 自动变为（即自动装箱【autoboxing】）
list.add(Integer.valueOf(3));
```

注释：自动打包（autowrapping）可能更合适，“装箱（boxing）”源于C#。

相反，Integer对象赋给一个int值，会自动拆箱。甚至在算术表达式也能自动装箱或拆箱，例如：

```java
Integer n = 3;
n++;
```

两个包装器对象比较时应该调用equals方法。

注释：自动装箱规范要求boolean、byte、char<=127，short和int介于-128~127。例如：

```java
// a == b 为false
Integer a = 1000;
Integer b = 1000;

// a == b 为true
Integer a = 100;
Integer b = 100;
```

警告：包装器类不能用来实现修改数值参数的方法，因为Java都是值传递。并且如Integer对象是final，不可变的。

如果想编写一个修改数值参数值的方法，需要使用在org.omg.CORBA包中定义的持有者（holder）类型，如IntHolder、BooleanHolder。

Integer常用API：

* int intValue()，以int形式返回值
* static String toString(int i)
* static String toString(int i,  int radix)，radix是进制
* Static int parseInt(String s)
* Static int parseInt(String s,  int radix)，radix是进制
* static Integer valueOf(String s)
* static Integer valueOf(String s, int radix)，radix是进制

5、参数数量可变的方法：也称为“变参”方法。

Java SE 5.0 以前的版本中，方法都有固定数量的参数。

```java
public class PrintStream {
  public PrintStream printf(String fmt, Object... args) {
    return format(fmt, args);
  }
}
```

省略号...表示可以接收任意数量的对象（除了fmt参数之外）。

注释：允许将一个数组传递给可变参数方法的最后一个参数。因此，可以将已经存在且最后一个参数是数组的方法重新定义为可变参数的方法，而不会破坏任何已经存在的代码。

6、枚举类：比较两个枚举类型的值时，永远不需要调用equals，直接调用“==”就可以了。

枚举类尽量不要构造新对象。

如果需要的话，可以再枚举类型中添加一些构造器、方法和域。当然，构造器只是在构造枚举常量的时候被调用。

示例：

```java
public enum Size {
  SMALL("S"),MEDIUM("m"),LARGE("L"),EXTRA_LARGE("XL");
  
  private String abbreviation;
  
  private Size(String abbreviation) {
    this.abbreviation = abbreviation;
  }
  public String getAbbreviation() {
    return abbreviation;
  }
}
```

所有的枚举类型都是Enum类的子类，并继承了许多方法。其中最有用的一个是toString，这个方法能够返回枚举常量名。如Size.SMALL.toString()将返回字符串"SMALL"。

toString的逆方法时静态方法valueOf。如：Size s = Enum.valueOf(Size.class, "SMALL");，将s设置成Size.SMALL。

每个枚举类型都有一个静态的values方法，它将返回一个包含全部枚举值的数组。

ordxinal方法返回enum声明中枚举常量的位置，位置从0开始计数。

int campareTo(E other)，如果枚举常量出现在other之前，则返回一个负值；this==other则是0；否则正值。

7、反射：能够分析类能力的程序称为反射（reflective）。

这项功能被大量地应用于JavaBeans中，是Java组件的体系结构。特别是在设计或运行中添加新类时，能够快速地应用开发工具动态地查询新添加类的能力。

反射机制可以用来：

* 在运行中分析类的能力。
* 在运行中查看对象。例如编写一个toString方法供所有类使用。
* 实现通用的数组操作代码。
* 利用Method对象，这个对象很像C++的函数指针。

